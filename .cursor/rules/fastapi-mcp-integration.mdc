---
description: 
globs: 
alwaysApply: false
---
# FastAPI-MCP Integration Patterns (2025)

## Overview

This project implements **FastAPI-to-MCP server conversion** using the recommended zero-duplication approach via `FastMCP.from_fastapi()`. This pattern enables AI agents to access existing FastAPI endpoints as MCP tools without code duplication.

## Primary Integration Pattern: FastMCP.from_fastapi()

The **core implementation** is in [fastapi_wrapper.py](mdc:src/mcp_server/fastapi_wrapper.py) using the recommended approach:

```python
from fastmcp import FastMCP
from src.main_api import app  # Existing FastAPI app

# Convert FastAPI app to MCP server (zero duplication)
mcp = FastMCP.from_fastapi(app=app)
```

## Architecture Benefits

- ✅ **Zero Code Duplication**: No need to rewrite business logic
- ✅ **Schema Inheritance**: Automatic Pydantic model conversion
- ✅ **Consistent API**: Single source of truth for endpoints
- ✅ **Production Ready**: Leverages existing FastAPI infrastructure

## Endpoint-to-Tool Mapping Rules

### Current Project Mapping
The [main_api.py](mdc:src/main_api.py) FastAPI endpoints automatically become MCP tools:

| FastAPI Endpoint | MCP Tool Name | Description |
|------------------|---------------|-------------|
| `/invoke/naive_retriever` | `naive_retriever` | Basic vector search |
| `/invoke/bm25_retriever` | `bm25_retriever` | Keyword-based search |
| `/invoke/contextual_compression_retriever` | `contextual_compression_retriever` | Compressed retrieval |
| `/invoke/multi_query_retriever` | `multi_query_retriever` | Multi-query expansion |
| `/invoke/ensemble_retriever` | `ensemble_retriever` | Hybrid search method |
| `/invoke/semantic_retriever` | `semantic_retriever` | Semantic vector search |

### FastMCP Conversion Rules
- **POST endpoints** → MCP tools (executable functions)
- **GET endpoints** → MCP resources (data sources)
- **Pydantic models** → Automatic schema conversion
- **FastAPI docs** → MCP tool descriptions

## Tool Naming

FastMCP automatically converts endpoint names to tool names using the established pattern in your implementation.

## Verification and Testing

### Primary Verification
Always verify MCP conversion with [verify_mcp.py](mdc:tests/integration/verify_mcp.py):

```bash
# Verify FastAPI-MCP conversion works correctly
uv run python tests/integration/verify_mcp.py
```

### Testing Workflow
```bash
# 1. Test FastAPI endpoints directly
uv run bash tests/integration/test_api_endpoints.sh

# 2. Verify MCP conversion
uv run python tests/integration/verify_mcp.py

# 3. Compare FastAPI vs MCP quality
uv run pytest tests/integration/functional_quality_comparison.py
```

## Production Deployment Options

### 1. Streamable HTTP (Recommended)
```python
# Production-ready HTTP transport
mcp.run(
    transport="streamable_http",
    host="0.0.0.0", 
    port=8000
)
```

### 2. ASGI Integration
```python
# Integrate with existing FastAPI infrastructure
from fastapi import FastAPI
from fastmcp import FastMCP

main_app = FastAPI()
mcp_server = FastMCP.from_fastapi(existing_app)

# Mount MCP endpoint alongside FastAPI
main_app.mount("/mcp", mcp_server)
```

### 3. Container Deployment
```dockerfile
# Dockerfile for MCP server
FROM python:3.11-slim
COPY requirements.txt .
RUN pip install -r requirements.txt
COPY src/ /app/src/
WORKDIR /app
CMD ["python", "-m", "src.mcp_server.fastapi_wrapper"]
```

### 4. Claude Desktop Integration
```bash
# Install for Claude Desktop usage
fastmcp install src/mcp_server/fastapi_wrapper.py --name "Advanced RAG"
```

## Error Handling and Logging

### Robust Error Handling
```python
# Pattern used in fastapi_wrapper.py
def create_mcp_server():
    try:
        from src.main_api import app
        mcp = FastMCP.from_fastapi(app=app)
        return mcp
    except Exception as e:
        logger.error(f"Failed to create MCP server: {e}")
        raise
```

### Logging Configuration
```python
import logging

# Configure logging for MCP server
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Log MCP server events
logger.info("FastMCP server created successfully")
```

## Advanced Features (June 2025)

### Security and Authentication
```python
from fastmcp.auth import bearer_auth

@bearer_auth("your-secret-key")
async def secured_mcp_endpoint():
    # Secured MCP tool
    pass
```

### Monitoring and Observability
```python
from opentelemetry import trace

tracer = trace.get_tracer(__name__)

@mcp.tool()
async def traced_operation():
    with tracer.start_as_current_span("mcp-operation"):
        # Traced MCP tool execution
        pass
```

### Custom Tool Transformation
```python
# Advanced: Custom tool transformation
from fastmcp.patterns import transform_tool

@transform_tool(name="enhanced_search")
async def enhanced_semantic_search(query: str):
    # Custom tool behavior
    pass
```

## Common Patterns and Solutions

### Path Resolution
```python
# Proper path resolution for imports
current_file = Path(__file__).resolve()
project_root = current_file.parent.parent.parent
sys.path.insert(0, str(project_root))
```

### Environment Dependencies
```python
# MCP server creation doesn't require backend services
# Services only needed when tools execute
logger.info("FastMCP acts as wrapper - backend services only needed when tools execute")
```

### Resource Management
```python
@asynccontextmanager
async def mcp_lifespan():
    # Initialize resources when first tool executes
    yield
    # Cleanup when server shuts down
```

## Integration with LangChain

For LangChain integration, use the MCP tools via langchain-mcp-adapters:

```python
from langchain_mcp_adapters import create_langchain_tool

# Convert MCP tools to LangChain tools
mcp_tool = create_langchain_tool(
    server_path="src/mcp_server/fastapi_wrapper.py",
    tool_name="semantic_retriever"
)
```

## Best Practices Summary

1. ✅ **Use FastMCP.from_fastapi()** for zero duplication
2. ✅ **Verify with tests** after any changes
3. ✅ **Follow naming conventions** for better UX
4. ✅ **Handle errors gracefully** with proper logging
5. ✅ **Test both FastAPI and MCP** endpoints
6. ✅ **Document tool purposes** clearly
7. ✅ **Use proper path resolution** for imports
8. ✅ **Consider production deployment** early
